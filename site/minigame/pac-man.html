<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pac-Man Fixed</title>
<style>
  body { margin:0; background:black; font-family:sans-serif; color:white;}
  #ui { position:absolute; top:10px; left:10px; font-size:24px;}
  canvas { display:block; margin:0 auto; background:#111;}
</style>
</head>
<body>
<div id="ui">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
<canvas id="game" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui');

const tileSize = 20;
const rows = canvas.height / tileSize;
const cols = canvas.width / tileSize;

// Create walls (1 = wall, 0 = empty)
let map = Array.from({length:rows},()=>Array(cols).fill(0));

// Outer walls
for(let r=0;r<rows;r++){ map[r][0]=1; map[r][cols-1]=1; }
for(let c=0;c<cols;c++){ map[0][c]=1; map[rows-1][c]=1; }

// Random inner walls
for(let i=0;i<100;i++){
  let r=Math.floor(Math.random()*(rows-2))+1;
  let c=Math.floor(Math.random()*(cols-2))+1;
  map[r][c]=1;
}

let pacman={x:1,y:1,dx:0,dy:0,speed:1};
let hearts=3;
let pellets=[];
let ghosts=[];
let powerOrb=null;
let abilityOrb=null;
let ghostEatable=false;
let ghostTimer=0;
let ability=null;
let teleportReady=false;

// Place pellets in empty tiles
for(let r=1;r<rows-1;r++){
  for(let c=1;c<cols-1;c++){
    if(map[r][c]===0){
      if(Math.random()<0.1) pellets.push({x:c,y:r,type:"gold"});
      else pellets.push({x:c,y:r,type:"normal"});
    }
  }
}

// Spawn ghosts away from player
function spawnGhosts(n){
  for(let i=0;i<n;i++){
    let gx,gy;
    do{
      gx=Math.floor(Math.random()*cols);
      gy=Math.floor(Math.random()*rows);
    } while(map[gy][gx]===1 || (Math.abs(gx-pacman.x)<5 && Math.abs(gy-pacman.y)<5));
    ghosts.push({x:gx,y:gy});
  }
}
spawnGhosts(4);

// Controls
window.addEventListener("keydown", e=>{
  if(e.key==="ArrowUp"){ pacman.dx=0; pacman.dy=-1; }
  if(e.key==="ArrowDown"){ pacman.dx=0; pacman.dy=1; }
  if(e.key==="ArrowLeft"){ pacman.dx=-1; pacman.dy=0; }
  if(e.key==="ArrowRight"){ pacman.dx=1; pacman.dy=0; }
  if(e.key===" " && teleportReady){
    let tx,ty;
    do{
      tx=Math.floor(Math.random()*cols);
      ty=Math.floor(Math.random()*rows);
    } while(map[ty][tx]===1);
    pacman.x=tx; pacman.y=ty;
    teleportReady=false;
  }
});

function update(){
  // Move Pac-Man
  let nx=pacman.x+pacman.dx;
  let ny=pacman.y+pacman.dy;
  if(map[ny][nx]===0){ pacman.x=nx; pacman.y=ny; }

  // Eat pellets
  for(let i=pellets.length-1;i>=0;i--){
    let p=pellets[i];
    if(p.x===pacman.x && p.y===pacman.y){
      if(p.type==="gold"){ hearts=Math.min(3,hearts+0.5); }
      pellets.splice(i,1);
    }
  }

  // Power orb
  if(powerOrb && pacman.x===powerOrb.x && pacman.y===powerOrb.y){
    ghostEatable=true; ghostTimer=500; powerOrb=null;
  }

  // Ability orb
  if(abilityOrb && pacman.x===abilityOrb.x && pacman.y===abilityOrb.y){
    if(abilityOrb.type==="speed"){ pacman.speed=2; setTimeout(()=>pacman.speed=1,5000); }
    if(abilityOrb.type==="magnet"){ ability="magnet"; setTimeout(()=>ability=null,5000); }
    if(abilityOrb.type==="teleport"){ teleportReady=true; }
    abilityOrb=null;
  }

  // Ghost movement
  for(let g of ghosts){
    let dx=Math.sign(pacman.x-g.x);
    let dy=Math.sign(pacman.y-g.y);
    if(ghostEatable){ dx*=-1; dy*=-1; }
    if(map[g.y][g.x+dx]===0) g.x+=dx;
    else if(map[g.y+dy][g.x]===0) g.y+=dy;

    if(g.x===pacman.x && g.y===pacman.y){
      if(ghostEatable){ hearts=Math.min(3,hearts+1); g.x=0; g.y=0; }
      else{ hearts-=1; pacman.x=1; pacman.y=1; if(hearts<=0){alert("Game Over"); hearts=3; pacman.x=1; pacman.y=1;} }
    }
  }

  if(ghostTimer>0){ ghostTimer--; if(ghostTimer<=0) ghostEatable=false; }

  // Spawn ability orb rarely
  if(!abilityOrb && Math.random()<0.002){
    let types=["speed","magnet","teleport"];
    let ax,ay;
    do{ ax=Math.floor(Math.random()*cols); ay=Math.floor(Math.random()*rows); } while(map[ay][ax]===1);
    abilityOrb={x:ax,y:ay,type:types[Math.floor(Math.random()*types.length)]};
  }

  // Spawn power orb rarely
  if(!powerOrb && Math.random()<0.001){
    let px,py;
    do{ px=Math.floor(Math.random()*cols); py=Math.floor(Math.random()*rows); } while(map[py][px]===1);
    powerOrb={x:px,y:py};
  }

  draw();
  requestAnimationFrame(update);
}

function draw(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Draw walls
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(map[r][c]===1){ ctx.fillStyle="blue"; ctx.fillRect(c*tileSize,r*tileSize,tileSize,tileSize); }
    }
  }

  // Draw pellets
  for(let p of pellets){
    ctx.fillStyle=p.type==="gold"?"gold":"white";
    ctx.fillRect(p.x*tileSize+6,p.y*tileSize+6,8,8);
  }

  // Draw power orb
  if(powerOrb){ ctx.fillStyle="blue"; ctx.beginPath(); ctx.arc(powerOrb.x*tileSize+10,powerOrb.y*tileSize+10,8,0,Math.PI*2); ctx.fill(); }

  // Draw ability orb
  if(abilityOrb){
    ctx.fillStyle=abilityOrb.type==="speed"?"lime":abilityOrb.type==="magnet"?"magenta":"cyan";
    ctx.beginPath(); ctx.arc(abilityOrb.x*tileSize+10,abilityOrb.y*tileSize+10,6,0,Math.PI*2); ctx.fill();
  }

  // Draw ghosts
  for(let g of ghosts){
    ctx.fillStyle=ghostEatable?"lightblue":"red";
    ctx.fillRect(g.x*tileSize+2,g.y*tileSize+2,16,16);
  }

  // Draw Pac-Man
  ctx.fillStyle="yellow";
  ctx.beginPath();
  ctx.arc(pacman.x*tileSize+10,pacman.y*tileSize+10,10,0,Math.PI*2);
  ctx.fill();

  // UI hearts
  let heartsUI="‚ù§Ô∏è".repeat(Math.floor(hearts));
  if(hearts%1!==0) heartsUI+="üíî";
  ui.textContent=heartsUI;
}

update();
</script>
</body>
</html>
